Raspberry Pi:

|--- data definitions ---|

a UID is a python bytes

physical_board: 8x8 array of UID
uid_to_piece: {UID -> chess.Piece}

NANO_LEFT_ADDR, NANO_RIGHT_ADDR

|--- funcs ---|

func read_halfboard(nano_addr) -> half_board:
    raw_block = i2c_read_block(nano_addr, CMD_GET_BLOCK)
    return reshape_raw_block_to_8x4(raw_block)

func assemble_full_board() -> board_state:
    left  = read_halfboard(NANO_LEFT_ADDR)
    right = read_halfboard(NANO_RIGHT_ADDR)
    new_board = UID[8x8]
    new_board = concat(left, right) # to be implemented
    return new_board

func detect_move(old_board, new_board):
    diff old_board vs new_board
    return uci string for move if diff is not none

|--- game logic ---|

when player move:
    new_board = read_board()
    old_board = self.physical_board
    self.physical_board = new_board

    move = detect_move()

    do rest of chess logic to verify move's legality,
    push to board and get AI move (already implemented)