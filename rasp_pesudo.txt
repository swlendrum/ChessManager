Raspberry Pi:

|--- data definitions ---|

a UID is a python bytes
(bytes is a python type representating an immutable sequence of UIDS)

an add_pair is a tuple (int, int) containing the multiplexer i2c address and channel ID for a specific NFC reader

|--- fields/vars ---|

board: our Board(chess.Board) class
    * interfaces with python's chess module
    * can easily print game state
    * automatic logic for determining move legality, etc

physical_board: 8x8 array of UID

sensor_map: 8x8 array of add_pair

uid_to_piece: {UID -> chess.Piece} preset map of UID to Piece

|--- funcs ---|

func detect_move(old_board, new_board):
    diff old_board vs new_board
    return uci string for move if diff is not none

func read_board() -> board_state:
    # generates new physical board state (8x8 UID array)
    new board = UID[8x8]
    for spot in new_board:
        new_board[spot] = read(spot)

func read(spot: (r,c)) -> UID (bytes):
    mul_add, chan_add = sensor_map(spot)
    nano, give me the UID read from that address combo
        (returns UID as 7-length array of 8-bit integers)
    return bytes(UID) # cast to our python type

|--- game logic ---|

when player move:
    new_board = read_board()
    old_board = self.physical_board
    self.physical_board = new_board

    move = detect_move()

    do rest of chess logic to verify move's legality,
    push to board and get AI move (already implemented)